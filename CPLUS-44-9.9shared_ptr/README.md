# shared_ptr
В языке *C++*, в отличие от других популярных высокоуровневых языков программирования, пользователь/разработчик должен сам отслеживать ресурсы программы.

В *C++* отсутствует так называемый *сборщик мусора* — механизм, который отслеживает использование ресурсов и уничтожает те ресурсы, на которые никто в программе больше не ссылается. Конечно, сборщик мусора — это очень удобный механизм, он позволяет разработчикам не думать об управлении ресурсами. Однако сборщик мусора требует отдельного вычислительного времени и использует ресурсы компьютера, что накладывает ограничения на производительность программ. 

В *C++* мы можем автоматически управлять ресурсами и временем их жизни с помощью `shared_ptr`. Ключевая особенность `shared_ptr` в том, что этот указатель отслеживает, кто ссылается на объект, и когда на объект уже никто не ссылается — уничтожает его.

Это достигается за счёт <b>счётчика ссылок</b>, встроенного в класс `shared_ptr`. Данный счетчик позволяет узнать, сколько сущностей ссылается на объект, и таким образом контролировать время жизни объекта. Если счётчик ссылок равен нулю — это сигнал `shared_ptr`, что объект уже никем не используется, и в деструкторе `shared_ptr`, при равенстве счетчика ссылок нулю, объект будет уничтожен.

`shared_ptr` поддерживает фукнции `get`, `reset` и `release`, как и остальные умные указатели, помимо этого у `shared_ptr` есть ещё один метод — `use_count()`. Это функция, которая возвращает текущее значение счётчика ссылок. 

`shared_ptr` можно создать несколькими способами:
1. С помощью конструктора:
```
shared_ptr<Int> p1(new Int(4));
```
2. Конвертацией из `unique_ptr`:
```
unique_ptr<Int> uptr(new Int(4));
shared_ptr<Int> p1(move(uptr));
```
Также, для удобства использования введена дополнительная функция `make_shared`, которая возвращает `shared_ptr` на объект:

```
shared_ptr<Int> ptr = make_shared<Int>(4);
```
`make_shared` также является безопасной для исключений и более быстрой, так как `make_shared` сразу создаёт место в памяти для контрольного блока и объекта.

Посмотрим на примере, как работает `shared_ptr` (см. исходный код main_01.cpp).

За такую прекрасную функциональность есть плата — `shared_ptr` вдвое больше обычного указателя за счёт того, что помимо указателя мы также должны хранить счётчик ссылок.

На самом деле `shared_ptr` не хранит счетчик ссылок непосредственно в самом классе, он хранит указатель на контрольный блок (*control block*) — другую, более крупную сущность. Контрольный блок хранит в себе помимо счетчика ссылок также счётчик слабых ссылок (*weak count*), о них поговорим чуть позже. Также он может хранить пользовательский распределитель памяти (аллокатор памяти) и пользовательскую функцию уничтожения объекта (перегруженный оператор `delete`).

<img src=media/cplus_m9_u6_p1.png alt=https://www.oreilly.com/library/view/effective-modern-c/9781491908419/ch04.html></img>

В теории, контрольный блок должен создаваться при первом создании `shared_ptr`, и затем указатель на контрольный блок должен передаваться другим `shared_ptr` при создании последних. Однако это не совсем так. 

```
Дело в том, что если мы работаем с обычным указателем на объект, 
мы не можем знать, есть ли где-то shared_ptr с указателем на этот 
объект, поэтому контрольный блок создается в нескольких случаях:

1. При вызове make_shared .
2. В случае, когда мы создаем shared_ptr от unique_ptr.
3. Когда мы создаем, то есть вызываем, конструктор shared_ptr с указателем на объект. 
```
Разные возможные варианты создания контрольного блока могут привести к тому, что у нас будет несколько контрольных блоков для одного объекта, что может привести к очень неожиданным результатам. Например, может так случиться, что у вас будет несколько независимых shared_ptr, которые не знают о существовании друг друга (см. исходный код main_02.cpp).

В итоге данная программа не сможет завершиться правильно, потому что объект будет уничтожен, хотя ещё два `shared_ptr` на него ссылаются.

На этот случай разработчики умных указателей реализовали для нас шаблонный класс:
```
enable_shared_from_this: template < class T > class enable_shared_from_this;
```
При наследовании от `enable_shared_from_this` мы получим класс, объекты которого можно безопасно хранить в умном указателе `shared_ptr`. Мы можем не бояться получить несколько контрольных блоков и быть уверенными в безопасности своевременного удаления объекта.

`
Примечание. Прежде чем вызывать shared_from_this, нужно создать хотя бы один shared_ptr с этим объектом, иначе мы получим exception std::bad_weak_ptr.
`

`enable_shared_from_this` является шаблонным классом, причём в качестве параметра шаблона мы предоставляем тип класса-наследника.

Например, для нашего класса Int:

```
#include <iostream>
#include <memory>

using namespace std;

class Int : public enable_shared_from_this<Int> // указываем класс Int как параметр шаблона enable_shared_from_this
{
public:
    Int(int i = 0) : _int(i) { cout << "constructor: " << _int << endl; } 
    ~Int() { cout << "destructor: " << _int << endl; }
    void SetInt(int i) { _int = i; cout << "Int set to: " << _int << endl; }
    int GetInt() { return _int; }

    shared_ptr<Int> GetPtr() { return shared_from_this(); } // метод, который возвращает shared_ptr
private:
    int _int;
}; 
```
Такой тип наследования называется *Curiously Recurring Template Pattern (CRTP)* и является одним из используемых паттернов проектирования. По сути, данный паттерн реализует статический полиморфизм, основываясь на знании класса, переданного в качестве параметра шаблона. Детальное устройство данного паттерна вы можете прочитать в <a src=https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/>статье</a> и на портале <a src=https://www.geeksforgeeks.org/curiously-recurring-template-pattern-crtp-2/>GeeksforGeeks</a>.

Вернемся к `enable_shared_from_this`.

Помимо базового класса `enable_shared_from_this` у нас также появляется метод `shared_from_this()`, который мы можем обернуть в какой-то пользовательский метод, который будет возвращать нам `shared_ptr`, когда у нас есть только чистый указатель на объект (см. исходный код main.cpp).

Вот теперь наша программа работает, как мы и ожидаем:

```
constructor: 4
2
3
4                             
2                
destructor: 4
```
Обычно в алгоритмах можно использовать `shared_ptr` там же, где бы мы использовали `unique_ptr`, поскольку в пределах ограниченной области видимости нам нужно лишь обеспечить автоматическое удаление объекта в конце блока кода. Однако в этом случае лучше использовать `unique_ptr`, поскольку идея использования указателя в таком случае понятнее.

Указатель `shared_ptr` используют, когда нужно безопасное совместное использование некого ресурса, который может быть возвращен из методов или в результате работы классов. Это делает проектирование программ с использованием разделяемых указателей чуть более сложным, но в C++ есть все необходимые инструменты, чтобы делать это на должном уровне и без ошибок.

*Дополнительный материал для знакомства с понятием vector вы можете найти в <a src=https://ru.wikipedia.org/wiki/Vector_(C%2B%2B)>данной статье</a>. Для более подробного изучения рекомендуем почитать этот <a src=https://en.cppreference.com/w/cpp/container/vector>ресурс</a>.*

```
void print_shared(std::shared_ptr<int> p)
{
    //используем указатель как пожелаем
    std::cout<<*p<<std::endl;
}

int main()
{
    //создаем вектор, который хранит «пошаренные» указатели
    std::vector< std::shared_ptr<int> > vec;
    for(int i=0; i < 10; i++)
    //заполняем вектор emplace
        vec.emplace_back(new int(i));
    
    //вызывает функцию, передавая в неё «пошаренный» указатель
    for(int i=0; i < 10; i++)
        print_shared(vec[i]);

    return 0;
}
```
Также `shared_ptr` можно использовать для создания классов только для чтения с автоматическим копированием.

Например:

```
class AutoCopyData
{
public:
//конструктор по умолчанию
    AutoCopyData()
    {}
    //конструктор, задающий размер внутренних данных
    AutoCopyData(size_t size)
    {
//создаем вектор нужного размера и заполняем его цифрами от 0 до size
         m_someBigData = std::make_shared<std::vector<int>>( size );
         for(size_t i= 0; i <size; i++)
            (*m_someBigData)[i] = i;
    }
    
    //возвращает размер внутренних данных
    size_t size()const
    {
    //если вызывался только конструктор по умолчанию, то указатель будет null, в этом случае возвращаем размер 0
        if(m_someBigData)
            return m_someBigData->size();
        return 0; 
    }
    
    //возвращаем значение по индексу
    int operator[](int index) const
    {
//тут можно еще проверять индекс на выход за пределы size
        if(m_someBigData)
              return (*m_someBigData)[index];
        return 0;
    }

private:
    //внутренние данные пошарены между несколькими возможными копиями объекта
    std::shared_ptr< std::vector<int> > m_someBigData;
};

int main()
{
//создаем объект с 10 элементами
    AutoCopyData data1(10);
//вызывается автоматический конструктор по умолчанию
    AutoCopyData copy1 = data1;
//вызывается автоматический конструктор по умолчанию
    AutoCopyData copy2 = copy1;
    
//проверяем, что в copy2 те же данные, что и в data1
    for(size_t i = 0; i < copy2.size();i++)
        std::cout<<copy2[i]<<" ";
    std::cout<<std::endl;


//деструкторы и очистку вызывать не надо, все делается автоматически
//повторного удаления нет

    return 0;
}
```
*Как мы видим, благодаря `shared_ptr` можно создать класс, который поддерживает разделение данных между несколькими своими копиями, что удобно и визуально достаточно просто. Можно в таком классе реализовывать также методы и для установки значений, но тут нужно помнить, что изменение данных в одной копии приведёт к изменению во всех остальных.*
