# shared_ptr
В языке *C++*, в отличие от других популярных высокоуровневых языков программирования, пользователь/разработчик должен сам отслеживать ресурсы программы.

В *C++* отсутствует так называемый *сборщик мусора* — механизм, который отслеживает использование ресурсов и уничтожает те ресурсы, на которые никто в программе больше не ссылается. Конечно, сборщик мусора — это очень удобный механизм, он позволяет разработчикам не думать об управлении ресурсами. Однако сборщик мусора требует отдельного вычислительного времени и использует ресурсы компьютера, что накладывает ограничения на производительность программ. 

В *C++* мы можем автоматически управлять ресурсами и временем их жизни с помощью `shared_ptr`. Ключевая особенность `shared_ptr` в том, что этот указатель отслеживает, кто ссылается на объект, и когда на объект уже никто не ссылается — уничтожает его.

Это достигается за счёт <b>счётчика ссылок</b>, встроенного в класс `shared_ptr`. Данный счетчик позволяет узнать, сколько сущностей ссылается на объект, и таким образом контролировать время жизни объекта. Если счётчик ссылок равен нулю — это сигнал `shared_ptr`, что объект уже никем не используется, и в деструкторе `shared_ptr`, при равенстве счетчика ссылок нулю, объект будет уничтожен.

`shared_ptr` поддерживает фукнции `get`, `reset` и `release`, как и остальные умные указатели, помимо этого у `shared_ptr` есть ещё один метод — `use_count()`. Это функция, которая возвращает текущее значение счётчика ссылок. 

`shared_ptr` можно создать несколькими способами:
1. С помощью конструктора:
```
shared_ptr<Int> p1(new Int(4));
```
2. Конвертацией из `unique_ptr`:
```
unique_ptr<Int> uptr(new Int(4));
shared_ptr<Int> p1(move(uptr));
```
Также, для удобства использования введена дополнительная функция `make_shared`, которая возвращает `shared_ptr` на объект:

```
shared_ptr<Int> ptr = make_shared<Int>(4);
```
`make_shared` также является безопасной для исключений и более быстрой, так как `make_shared` сразу создаёт место в памяти для контрольного блока и объекта.

Посмотрим на примере, как работает `shared_ptr` (см. исходный код).

За такую прекрасную функциональность есть плата — `shared_ptr` вдвое больше обычного указателя за счёт того, что помимо указателя мы также должны хранить счётчик ссылок.

На самом деле `shared_ptr` не хранит счетчик ссылок непосредственно в самом классе, он хранит указатель на контрольный блок (*control block*) — другую, более крупную сущность. Контрольный блок хранит в себе помимо счетчика ссылок также счётчик слабых ссылок (*weak count*), о них поговорим чуть позже. Также он может хранить пользовательский распределитель памяти (аллокатор памяти) и пользовательскую функцию уничтожения объекта (перегруженный оператор `delete`).

<img src=media/cplus_m9_u6_p1.png alt=https://www.oreilly.com/library/view/effective-modern-c/9781491908419/ch04.html></img>

В теории, контрольный блок должен создаваться при первом создании `shared_ptr`, и затем указатель на контрольный блок должен передаваться другим `shared_ptr` при создании последних. Однако это не совсем так. 

```
Дело в том, что если мы работаем с обычным указателем на объект, 
мы не можем знать, есть ли где-то shared_ptr с указателем на этот 
объект, поэтому контрольный блок создается в нескольких случаях:

1. При вызове make_shared .
2. В случае, когда мы создаем shared_ptr от unique_ptr.
3. Когда мы создаем, то есть вызываем, конструктор shared_ptr с указателем на объект. 
```
Разные возможные варианты создания контрольного блока могут привести к тому, что у нас будет несколько контрольных блоков для одного объекта, что может привести к очень неожиданным результатам. Например, может так случиться, что у вас будет несколько независимых shared_ptr, которые не знают о существовании друг друга.