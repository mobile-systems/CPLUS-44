# auto_ptr 
Несмотря на то, что начиная с C++ 11 *auto_ptr* является устаревшим, а начиная с C++ 17 он убран из стандарта, этот указатель имеет некоторое историческое значение, поэтому наше рассмотрение мы начинаем с него.

Рассмотрим пример:

```
void memory_leak() 
{
	A* ptr = new A;
	// большой блок кода, который может генерировать исключения
	delete ptr;
} 
```
Рассмотрим функцию *memory_leak*. В начале функции мы создаём некий указатель на объект класса A, затем мы проводим с ним некоторую работу, причем мы не можем знать наверняка, насколько безопасен код. Что если во время выполнения в коде будет сгенерировано исключение? Тогда выход из функции произойдет раньше, чем вызов оператора *delete*, и таким образом у нас появится утечка памяти.

Одно из возможных решений в такой ситуации — обернуть блок кода между *new* и *delete* в блок *try*, чтобы отловить возможные исключения, обработать их и вызвать в конечном итоге *delete* :
```
void memory_leak() 
{
    ClassA * ptr = new ClassA;
    try {
    ...
    }
    catch(...)     {
        delete ptr;
        throw;
    }
    delete ptr;
}
```
Код стал выглядеть намного сложнее, читать его стало труднее. А писать каждый раз блоки *try* после выделения ресурса в памяти кажется совсем сложным.

Другое решение — использовать умный указатель. Умный указатель является примером идиомы *RAII*. То есть в конструкторе умный указатель захватывает ресурсы, а в деструкторе при уничтожении — освобождает.

Поскольку умный указатель является локальной переменной, он будет уничтожен при выходе из функции, в том числе и в случае генерации исключений. Тогда в функции *memory_leak* мы можем использовать данный указатель и переписать код:
```
#include <memory>
void memory_leak() 
{
    auto_ptr<A> ptr(new A);
    // большой блок кода, который может генерировать исключения
} 
```
Теперь нам больше не нужны ни блоки *try*, ни оператор *delete*, вся работа по уничтожению ресурса скрыта в умном указателе.

*auto_ptr* определен в заголовочном файле `<memory`> и является шаблонным классом, где тип шаблона соответствует типу объекта, который хранится в умном указателе.

*auto_ptr*, как и все остальные указатели, поддерживает привычный интерфейс для указателей. Оператор * разыменовывает указатель, а оператор -> дает доступ к открытым данным и функциям объекта. Также умные указатели имеют ещё одну функцию — *get()*, которая возвращает адрес хранимого объекта, то есть Си-указатель на хранимый объект.

Однако у *auto_ptr* есть ряд ограничений.

1. Для *auto_ptr* не реализована операция присваивания:

```
auto_ptr<A> ptr(new A);	// мы можем создать новый указатель
auto_ptr<A> ptr = new A; // ошибка! нельзя присваивать значение auto_ptr
```
2. Ещё одно важное ограничение *auto_ptr* — отсутствие поддержки массивов. Дело в том, что массивы мы должны уничтожать с помощью оператора *delete[]*, однако *auto_ptr* умеет использовать только обычный оператор *delete*.

Рассмотрим работу *auto_ptr* на простом примере (см. исходный код).

Вывод программы:

```
constructor: 3
Int set to: 1
object value: 1
object value using get: 1
destructor: 1
```
*auto_ptr* считается устаревшим и не стоит его использовать. Устаревшим он считается из-за своего родства со следующим указателем — *unique_ptr*, который позволяет делать гораздо больше, чем *auto_ptr*.
