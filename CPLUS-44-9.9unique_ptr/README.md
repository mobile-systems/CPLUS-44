# unique_ptr
`unique_ptr` — новый умный указатель с аналогичной функциональностью, но с улучшенной безопасностью, добавленными функциями (пользовательская функция удаления ресурса) и поддержкой массивов.

`unique_ptr` был разработан в `C ++ 11` как замена `auto_ptr`. 

Указатель `unique_ptr` очень производительный, он не накладывает дополнительных расходов по сравнению с обычным указателем и занимает ровно столько же памяти.

`unique_ptr` поддерживает семантику эксклюзивного владения ресурсами. Данный указатель нельзя копировать. Он явно предотвращает копирование содержащегося в нём указателя, как это произошло бы при обычном назначении, то есть разрешает только одного владельца базового указателя.

Таким образом, при использовании `unique_ptr` на любом ресурсе может быть не более одного `unique_ptr`, и когда этот `unique_ptr` уничтожается, ресурс автоматически также уничтожается.

Кроме того, поскольку для любого ресурса может быть только один `unique_ptr`,  любая попытка сделать копию `unique_ptr` приведёт к ошибке времени компиляции.

Однако `unique_ptr` является перемещаемым типом, то есть поддерживает семантику перемещений. Это означает, что хоть мы не можем копировать `unique_ptr`, мы можем передать владение от одного `unique_ptr` другому:
```
unique_ptr<Int> ptr( new Int(2));
unique_ptr<Int> ptr2 = ptr; // ошибка компиляции
unique_ptr<Int> ptr2 = move(ptr); // разрешено, передали объект Int указателю ptr2
```
После операции перемещения старый указатель (то есть тот, который стоит справа от знака присваивания) становится nullptr (см. исходный код).

Вывод программы:
```
constructor: 2                                                                         
Int set to: 1                                                                          
object value: 1                                                                 
ptr2 value: 1                                                               
1                                                              
destructor: 1 
```
Видно, что `ptr == nullptr` возвращает `true`, потому что после перемещения `ptr` теперь не хранит никаких данных.

Помимо стандартного синтаксиса создания `unique_ptr` с помощью конструктора `unique_ptr<Int> ptr( new Int(2))`, существует ещё функция создания `unique_ptr` — `make_unique`.

`make_unique` позволяет нам избежать необходимости писать оператор выделения памяти `new`, а также данная функция является безопасной с точки зрения исключений, поэтому считается более предпочтительной, чем обычное создание `unique_ptr` с помощью конструктора.

Чтобы создать `unique_ptr` с помощью `make_unique`, необходимо в параметрах шаблона функции `make_unique` указать тип объекта, а в круглых скобках передать аргументы для конструктора объекта:

```unique_ptr<Int> ptr = make_unique<Int>(4);```

Использовать `unique_ptr` можно в любом случае, в котором мы бы использовали обычный указатель на временный объект в динамической памяти. Например, для создания указателя на выделенную переменную или массив в памяти в некотором алгоритме.

Приведём код для примера:

```
//создание уникального указателя на выделенный массив из 10 int-ов
std::unique_ptr<int[]> arr = std::make_unique<int[]>(10);
//заполняем массив значениями
for(int i = 0; i < 10; i++)
   arr[i] = i;

//читаем значения из массива
for(int i = 0; i < 10; i++)
   std::cout<<arr[i]<<std::endl;

//удалять специально не надо, всё за нас делает unique_ptr
```
Синтаксис может выглядеть несколько более громоздко по сравнению с применением `new` и `delete`, однако применение умного указателя избавляет нас от необходимости следить за освобождением ресурсов и гарантированно защищает от утечек памяти. Поэтому стоит выработать привычку писать код с использованием умных указателей.

Есть, пожалуй, всего две ошибки, которые вы можете допустить при работе с `unique_ptr` и другими умными указателями:

- Выделить память где-то ещё и потом присвоить указатель сразу двум указателям.
- Оформить указатель на объект в стеке. В этом случае произойдет двойное удаление объекта (или попытка).

```
int* raw = new int(1);
std::unique_ptr<int> p1 = std::unique_ptr(raw); //так делать не надо
std::unique_ptr<int> p2 = std::unique_ptr(raw); //так делать не надо
    
int i_on_stack = 1;
std::unique_ptr<int> p1 = std::unique_ptr(&i_on_stack); //так тоже делать не надо
```
Использование `make_unique` защищает вас от таких ошибок, поэтому по возможности используйте его. Указатель `make_unique` включен в стандарт с *C++14*.