Работа с памятью и указателями всегда была нелёгкой, и программистам приходилось придумывать способы сделать её более простой, безопасной и эффективной. Умные указатели были всегда, однако с выходом C++11 они попали в стандарт, а новые возможности языка, пришедшие вместе со стандартом, о которых мы говорили ранее, сделали их ещё эффективнее.

Умные указатели настолько важны, что буквально на каждом собеседовании вас спросят об этой теме. Умные указатели не только помогают создавать более безопасные программы, но также делают код более читаемым, а поддержку кода более легкой.

<b>Какие же проблемы возникают при работе с обычными указателями (raw pointers, от англ. «сырые указатели»)?</b>
- Обычный указатель не даёт информацию о том, указывает он на объект или на массив.
- Нет никакой информации о том, кто должен удалять ресурс, на который указывает указатель.
- Нет информации о том, как удалять объект, на который указывает указатель.
- Нет возможности понять, был ли уже удалён объект.

Это лишь краткий список основных проблем, которые могут возникнуть при работе с сырыми указателями.

Умные указатели призваны решить данные проблемы. Умные указатели — это обёртки над обычными указателями, которые позволяют управлять ресурсами, на которые они указывают, и предоставляют гораздо больше информации об использовании этих ресурсов (как удалять ресурсы, кто должен их удалять и когда).

В *C++* существует четыре основных умных указателя:

- auto_ptr;
- unique_ptr;
- shared_ptr;
- weak_ptr.

# auto_ptr 
Несмотря на то, что начиная с C++ 11 *auto_ptr* является устаревшим, а начиная с C++ 17 он убран из стандарта, этот указатель имеет некоторое историческое значение, поэтому наше рассмотрение мы начинаем с него.

Рассмотрим пример:

```
void memory_leak() 
{
	A* ptr = new A;
	// большой блок кода, который может генерировать исключения
	delete ptr;
} 
```
Рассмотрим функцию *memory_leak*. В начале функции мы создаём некий указатель на объект класса A, затем мы проводим с ним некоторую работу, причем мы не можем знать наверняка, насколько безопасен код. Что если во время выполнения в коде будет сгенерировано исключение? Тогда выход из функции произойдет раньше, чем вызов оператора *delete*, и таким образом у нас появится утечка памяти.

Одно из возможных решений в такой ситуации — обернуть блок кода между *new* и *delete* в блок *try*, чтобы отловить возможные исключения, обработать их и вызвать в конечном итоге *delete* :
```
void memory_leak() 
{
    ClassA * ptr = new ClassA;
    try {
    ...
    }
    catch(...)     {
        delete ptr;
        throw;
    }
    delete ptr;
}
```
Код стал выглядеть намного сложнее, читать его стало труднее. А писать каждый раз блоки *try* после выделения ресурса в памяти кажется совсем сложным.

Другое решение — использовать умный указатель. Умный указатель является примером идиомы *RAII*. То есть в конструкторе умный указатель захватывает ресурсы, а в деструкторе при уничтожении — освобождает.

Поскольку умный указатель является локальной переменной, он будет уничтожен при выходе из функции, в том числе и в случае генерации исключений. Тогда в функции *memory_leak* мы можем использовать данный указатель и переписать код:
```
#include <memory>
void memory_leak() 
{
    auto_ptr<A> ptr(new A);
    // большой блок кода, который может генерировать исключения
} 
```
Теперь нам больше не нужны ни блоки *try*, ни оператор *delete*, вся работа по уничтожению ресурса скрыта в умном указателе.

*auto_ptr* определен в заголовочном файле `<memory`> и является шаблонным классом, где тип шаблона соответствует типу объекта, который хранится в умном указателе.

*auto_ptr*, как и все остальные указатели, поддерживает привычный интерфейс для указателей. Оператор * разыменовывает указатель, а оператор -> дает доступ к открытым данным и функциям объекта. Также умные указатели имеют ещё одну функцию — *get()*, которая возвращает адрес хранимого объекта, то есть Си-указатель на хранимый объект.

Однако у *auto_ptr* есть ряд ограничений.

1. Для *auto_ptr* не реализована операция присваивания:

```
auto_ptr<A> ptr(new A);	// мы можем создать новый указатель
auto_ptr<A> ptr = new A; // ошибка! нельзя присваивать значение auto_ptr
```
2. Ещё одно важное ограничение *auto_ptr* — отсутствие поддержки массивов. Дело в том, что массивы мы должны уничтожать с помощью оператора *delete[]*, однако *auto_ptr* умеет использовать только обычный оператор *delete*.

Рассмотрим работу *auto_ptr* на простом примере (см. исходный код).

Вывод программы:

```
constructor: 3
Int set to: 1
object value: 1
object value using get: 1
destructor: 1
```
*auto_ptr* считается устаревшим и не стоит его использовать. Устаревшим он считается из-за своего родства со следующим указателем — *unique_ptr*, который позволяет делать гораздо больше, чем *auto_ptr*.
