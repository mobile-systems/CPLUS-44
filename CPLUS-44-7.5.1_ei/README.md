# Исключения  и наследование
Мы убедились, что объекты классов можно использовать для генерации исключений, а так как классы могут быть унаследованы от других классов, необходимо посмотреть, что происходит, когда мы используем унаследованные классы в качестве исключений. Оказывается, обработчики исключений могут не только сопоставлять классы определенного типа, но и сопоставлять классы, производные от этого конкретного типа!

Рассмотрим следующий пример:

CODE

У нас имеется иерархия классов: Base — базовый класс и Derived — класс-наследник. В блоке try мы генерируем исключение типа Derived, однако в выводе программы мы увидим, что перехвачено было исключение типа Base:

<code>Exception: caught Base class</code>
<p><b>Общее правило для работы с исключениями производных классов:</b> обработчики для производных классов исключений должны быть перечислены перед обработчиками для базовых классов. Другими словами, мы должны перечислять исключения по принципу  «от самого узко применяемого до самого широко применяемого». </p>
Почему так произошло? Дело в том, что поскольку открытое наследование реализует отношения  «Является», значит Derived является Base, соответственно обработчик исключения Base может обработать исключение Derived. Также не стоит забывать, что когда C++ пытается найти обработчик возникшего исключения, он делает это последовательно, то есть идет от первого блока catch к последнему. Следовательно, первое, что делает C++, — это проверяет, соответствует ли обработчик исключений для Base исключению Derived. Поскольку Derived является Base, то исключение будет перехвачено первым блоком catch — обработчиком базового класса Base.